#version 450

#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable

layout (local_size_x = 16, local_size_y = 16) in;
layout (binding = 0, rgba8) uniform readonly image2D[1] inputImage;
layout (binding = 1, rgba8) uniform image2D[1] outputImage;
layout (binding = 2) uniform Frame {vec4 f;}frame;

const int SIZE = 9;

struct ImageData
{
	float r[SIZE];
	float g[SIZE];
	float b[SIZE];
} imageData;

float conv(in float[SIZE] kernel, in float[SIZE] data, in float denom, in float offset) 
{
	float res = 0.0;
	for (int i = 0; i < SIZE; i++)
	{
		res += kernel[i] * data[i];
	}
	return clamp(res/denom + offset, 0.0, 1.0);
}

void main()
{
	int frame = int(frame.f.x);
	
	for(int l = 0; l < 2; l++)
	{
		const int limit = 2;
		int n = 0;
		for(int i = -limit; i <= limit; i++)
		{
			for(int j = -limit; j <= limit; j++)
			{
				vec3 rgb = imageLoad(inputImage[l], ivec2(gl_GlobalInvocationID.x + i, gl_GlobalInvocationID.y + j)).rgb;
				imageData.r[n] = rgb.r;
				imageData.g[n] = rgb.g;
				imageData.b[n] = rgb.b;
				n++;
			}
		}

		float[SIZE] kernel;
		//kernel[0]  = 1; kernel[1]  = 4; kernel[2]  = 7; kernel[3]  = 4; kernel[4]  = 1; 
		//kernel[5]  = 4; kernel[6]  = 16; kernel[7]  = 26; kernel[8]  = 16; kernel[9]  = 4;
		//kernel[10] = 7; kernel[11] = 26; kernel[12] = 41; kernel[13] = 26; kernel[14] = 7;
		//kernel[15] = 4; kernel[16] = 16; kernel[17] = 26; kernel[18] = 16; kernel[19] = 4;
		//kernel[20] = 1; kernel[21] = 4; kernel[22] = 7; kernel[23] = 4; kernel[24] = 1;
		
		for(int i = 0; i < SIZE; i++){
			kernel[i] = 1;
		}
		//kernel[4] = 1.0;

		vec4 color = vec4(
			conv(kernel, imageData.r, 9/*273.0*/, 0.0),
			conv(kernel, imageData.g, 9/*273.0*/, 0.0),
			conv(kernel, imageData.b, 9/*273.0*/, 0.0),
			1
		);

		imageStore(outputImage[l], ivec2(gl_GlobalInvocationID.xy), color);
	}
}