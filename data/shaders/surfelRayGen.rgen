#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "helpers.glsl"
#include "surfelGIutils.glsl"

layout (set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 0, binding = 2) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
	vec4 frame;
} cam;
layout (set = 0, binding = 4) buffer Lights { Light lights[]; } lightsBuffer;
layout (set = 0, binding = 10) uniform sampler2D[] environmentTexture;


layout (set = 0, binding = 13) buffer SurfelBuffer {
	Surfel surfelInBuffer[];
} surfels;

layout (set = 0, binding = 14) buffer StatsBuffer {uint stats[8];} statsBuffer;

layout (set = 0, binding = 15) buffer GridBuffer {
	SurfelGridCell cells[];
} gridcells;
layout (set = 0, binding = 16) buffer CellBuffer {uint indexSurf[];} surfelcells;

layout (set = 0, binding = 17) buffer SurfelDataBuffer {
	SurfelData surfelDataInBuffer[];
} surfelsData;



layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

//layout (local_size_x = SURFEL_INDIRECT_NUMTHREADS, local_size_y = 1, local_size_z = 1) in;


void main()
{

	uint surfel_count = statsBuffer.stats[0];

	if (gl_LaunchIDEXT.x  >= surfel_count)
	{
		return;
	}

	int surfel_index = int(gl_LaunchIDEXT.x);

	SurfelData surfel_data = surfelsData.surfelDataInBuffer[surfel_index];
	Surfel surfel = surfels.surfelInBuffer[surfel_index];
	
	vec3 n = normalize(surfel.normal);

	uint frame = int(cam.frame.x);
	prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, frame);

	float seed = 0.123456;
	vec2 uv = vec2(fract(frame / 4096.0), float(surfel_index) / float(SURFEL_CAPACITY));

	float tmin 				= 0.001;
	float tmax 				= 1000.0;

	vec3 finalColor 		= vec3(0);
	vec3 origin 			= surfel.position;
	vec3 direction 			= normalize(SampleHemisphere_cos(n, seed, uv)); //el sample cos ese

	//vec3 direction 			= n;
	float attenuation 		= 1.0;
	float shadowFactor		= 0.0;
	vec3 rayColor = vec3(0.0);

	traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + direction * 1e-2, tmin, direction, tmax, 0);

	vec3 result = vec3(0);
	vec3 energy = vec3(1);

	rayColor = prd.colorAndDist.xyz;
	surfel.color = rayColor;

	surfels.surfelInBuffer[surfel_index] = surfel;

}