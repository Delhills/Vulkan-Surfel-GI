#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "helpers.glsl"
#include "surfelGIutils.glsl"

layout (set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 0, binding = 2) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
	vec4 frame;
} cam;
layout (set = 0, binding = 4) buffer Lights { Light lights[]; } lightsBuffer;
layout (set = 0, binding = 10) uniform sampler2D[] environmentTexture;


layout (set = 0, binding = 13) buffer SurfelBuffer {
	Surfel surfelInBuffer[];
} surfels;

layout (set = 0, binding = 14) buffer StatsBuffer {uint stats[8];} statsBuffer;

layout (set = 0, binding = 15) buffer GridBuffer {
	SurfelGridCell cells[];
} gridcells;
layout (set = 0, binding = 16) buffer CellBuffer {uint indexSurf[];} surfelcells;

layout (set = 0, binding = 17) buffer SurfelDataBuffer {
	SurfelData surfelDataInBuffer[];
} surfelsData;



layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool shadowed;

//layout (local_size_x = SURFEL_INDIRECT_NUMTHREADS, local_size_y = 1, local_size_z = 1) in;


void main()
{

	uint surfel_count = statsBuffer.stats[0];

	if (gl_LaunchIDEXT.x  >= surfel_count)
	{
		return;
	}

	int surfel_index = int(gl_LaunchIDEXT.x);

	prd.surfel_index = surfel_index;

	SurfelData surfel_data = surfelsData.surfelDataInBuffer[surfel_index];
	Surfel surfel = surfels.surfelInBuffer[surfel_index];
	
	vec3 n = normalize(surfel.normal);

	uint frame = int(cam.frame.x);
	//float seed = tea(float(surfel_index) / float(SURFEL_CAPACITY), frame);


	//float seed = fract(frame / 4096.0) + (float(surfel_index) / float(SURFEL_CAPACITY) * 3.43121412313);
	
	prd.seed = vec4(frame  + float(surfel_index)  * 3.43121412313);

	prd.seed.y =  tea(surfel_index, frame);
	//float seed = 0.123456;
	//vec2 uv = vec2(fract(float(frame) / 4096.0), float(surfel_index) / float(SURFEL_CAPACITY));

	float tmin 				= 0.01;
	float tmax 				= 100.0;

	vec3 finalColor 		= vec3(0);
	vec3 origin 			= surfel.position;
	
	//vec3 direction 			= normalize(uniformSampleHemisphere(n, seed));
	vec3 direction 			= normalize(cosineSampleHemisphere(n, prd.seed.x));
	//vec3 direction 			= SampleHemisphere_cos(-n, seed, uv);



	prd.colorAndDist = vec4(0.0);
	prd.energy = vec4(1.0);

	traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + direction * 1e-2, tmin, direction, tmax, 0);

	float shadowFactor              = 1.0;
	// for(int i = 0; i < lightsBuffer.lights.length(); i++)
	// {
	// 	// Init basic light information
	// 	Light light						= lightsBuffer.lights[i];
	// 	const bool isDirectional        = light.pos.w < 0;
	// 	vec3 L							= isDirectional ? light.pos.xyz : (light.pos.xyz - surfel.position);


	// 	const float light_max_distance 	= light.pos.w;
	// 	const float light_distance		= length(L);
	// 	L 								= normalize(L);

	// 	//const float light_intensity		= (100.0 / (light_distance * light_distance));
	// 	const float NdotL				= clamp(dot(surfel.normal, L), 0.0, 1.0);
		

	// 	if(NdotL > 0)
	// 	{
	// 		for(int a = 0; a < 1; a++)
	// 		{
	// 			// Init as shadowed
	// 			shadowed 	        = true;
	// 			// if(light_distance < light_max_distance)
	// 			// {
	// 			vec3 dir          = L;
	// 			const uint flags  = gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT;
	// 			float tmin = 0.001, tmax  = light_distance - 0.001;

	// 			// Shadow ray cast
	// 			traceRayEXT(topLevelAS, flags, 0xff, 0, 0, 1, 
	// 			surfel.position.xyz + dir * 0.01, tmin, dir, tmax, 1);
	// 			// }

	// 			if(shadowed){
	// 				shadowFactor = 0.0;
	// 			}
	// 			else{
	// 				shadowFactor = 1.0;
	// 			}
	// 		}
	// 	}
	// }

	



	// Light light 				    = lightsBuffer.lights[0];

	// vec3 color = light.color.xyz;
	
	surfel_data.hitenergy = prd.energy.xyz;
	surfel_data.traceresult = prd.colorAndDist.xyz * shadowFactor;

	//surfel.color = rayColor;

	//surfel.color = vec3(1.0, 0.0, 1.0);


	//surfels.surfelInBuffer[surfel_index] = surfel;
	surfelsData.surfelDataInBuffer[surfel_index] = surfel_data;

}