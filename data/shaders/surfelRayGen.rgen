#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "helpers.glsl"
#include "surfelGIutils.glsl"

layout (set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 0, binding = 2) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
	vec4 frame;
} cam;
layout (set = 0, binding = 4) buffer Lights { Light lights[]; } lightsBuffer;
layout (set = 0, binding = 10) uniform sampler2D[] environmentTexture;


layout (set = 0, binding = 13) buffer SurfelBuffer {
	Surfel surfelInBuffer[];
} surfels;

layout (set = 0, binding = 14) buffer StatsBuffer {uint stats[8];} statsBuffer;

layout (set = 0, binding = 15) buffer GridBuffer {
	SurfelGridCell cells[];
} gridcells;
layout (set = 0, binding = 16) buffer CellBuffer {uint indexSurf[];} surfelcells;

layout (set = 0, binding = 17) buffer SurfelDataBuffer {
	SurfelData surfelDataInBuffer[];
} surfelsData;



layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

//layout (local_size_x = SURFEL_INDIRECT_NUMTHREADS, local_size_y = 1, local_size_z = 1) in;


void main()
{

	uint surfel_count = statsBuffer.stats[0];

	if (gl_LaunchIDEXT.x  >= surfel_count)
	{
		return;
	}

	int surfel_index = int(gl_LaunchIDEXT.x);

	prd.surfel_index = surfel_index;

	SurfelData surfel_data = surfelsData.surfelDataInBuffer[surfel_index];
	Surfel surfel = surfels.surfelInBuffer[surfel_index];
	
	vec3 n = normalize(surfel.normal);

	uint frame = int(cam.frame.x);
	//float seed = tea(float(surfel_index) / float(SURFEL_CAPACITY), frame);


	//float seed = fract(frame / 4096.0) + (float(surfel_index) / float(SURFEL_CAPACITY) * 3.43121412313);
	
	float seed = frame  + float(surfel_index)  * 3.43121412313;
	//float seed = 0.123456;
	//vec2 uv = vec2(fract(float(frame) / 4096.0), float(surfel_index) / float(SURFEL_CAPACITY));

	float tmin 				= 0.01;
	float tmax 				= 100.0;

	vec3 finalColor 		= vec3(0);
	vec3 origin 			= surfel.position;
	
	//vec3 direction 			= normalize(uniformSampleHemisphere(n, seed));
	vec3 direction 			= normalize(cosineSampleHemisphere(n, seed));
	//vec3 direction 			= SampleHemisphere_cos(-n, seed, uv);



	prd.colorAndDist = vec4(0.0);
	prd.energy = vec4(1.0);

	traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + direction * 1e-2, tmin, direction, tmax, 0);




	// Light light 				    = lightsBuffer.lights[0];

	// vec3 color = light.color.xyz;
	
	surfel_data.hitenergy = prd.energy.xyz;
	surfel_data.traceresult = prd.colorAndDist.xyz;

	//surfel.color = rayColor;

	//surfel.color = vec3(1.0, 0.0, 1.0);


	//surfels.surfelInBuffer[surfel_index] = surfel;
	surfelsData.surfelDataInBuffer[surfel_index] = surfel_data;

}