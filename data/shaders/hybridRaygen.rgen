#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "helpers.glsl"

struct GPUMaterial
{
	vec4 diffuse;
	vec4 textures;
	vec4 shadingMetallicRoughness;
};

layout (set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 0, binding = 1, rgba8) uniform image2D image;
layout (set = 0, binding = 2) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;
layout (set = 0, binding = 3) uniform sampler2D positionTexture;
layout (set = 0, binding = 4) uniform sampler2D normalTexture;
layout (set = 0, binding = 5) uniform sampler2D albedoTexture;
layout (std140, set = 0, binding = 6) buffer Lights { Light lights[]; } lightsBuffer;
layout (set = 0, binding = 11) buffer MaterialBuffer { Material mat[]; } materials;

layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

const int MAX_RECURSION = 10;

float schlick(float f0, float f90, float NoV)
{
	return f0 + (f90 - f0) * pow(1.0 - NoV, 5.0);
}

float fresnel(float NoV)
{
	return schlick(0.0, 1.0, NoV);
}

void main()
{

	uint seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y);
	float r1 = rnd(seed);
	float r2 = rnd(seed);

    const vec2 pixelCenter	= vec2(gl_LaunchIDEXT.xy) + vec2(r1, r2);	// gl_LaunchIDEXT represents the floating-point pixel coordinates normalized between 0 and 1
	const vec2 inUV 		= pixelCenter/vec2(gl_LaunchSizeEXT.xy);	//gl_LaunchSizeExt is the image size provided in the traceRayEXT function
	vec2 d 					= inUV * 2.0 - 1.0;

	float matIdx 			= round(texture(positionTexture, inUV).w * 100);
	Material mat 			= materials.mat[int(matIdx)];
	int shadingMode 		= int(mat.shadingMetallicRoughness.x);

    vec3 position 			= texture(positionTexture, inUV).xyz;
	vec3 normal 			= texture(normalTexture, inUV).xyz * 2.0 - vec3(1);
	vec3 albedo 			= texture(albedoTexture, inUV).xyz;
	bool background 		= texture(positionTexture, inUV).w == 0 && texture(normalTexture, inUV).w == 0;

	// Using the pixel coordinates we can apply the inverse transformation of the view and procjection matrices of the camera to obtain
	// the origin and target of the ray
	const vec4 camPosition	= cam.viewInverse * vec4(0,0,0,1);
    const vec3 V			= normalize(camPosition.xyz - position);
    const vec3 N 			= normalize(normal);

	float tmin 				= 0.001;
	float tmax 				= 10000.0;

	vec3 finalColor 		= vec3(0);
	vec3 origin 			= vec3(0);
	vec3 direction 			= vec3(0);
	float attenuation 		= 1.0;

	// Calculate the light influence for each light
	for(int i = 0; i < lightsBuffer.lights.length(); i++)
	{
		Light light 				= lightsBuffer.lights[i];
		bool isDirectional 			= light.pos.w < 0;

		vec3 L 						= isDirectional ? light.pos.xyz : light.pos.xyz - position.xyz;
		float light_max_distance 	= light.pos.w;
		float light_distance 		= length(L);
		L 							= normalize(L);
		float NdotL 				= clamp(dot(N, L), 0.0, 1.0);
		float light_intensity 		= isDirectional ? 1.0f : (light.color.w / (light_distance * light_distance));

		int depth = 0;
		
		if(NdotL > 0)
		{
			isShadowed 	= true;
			tmax		= light_distance;
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT | gl_RayFlagsTerminateOnFirstHitEXT | gl_RayFlagsSkipClosestHitShaderEXT, 0xff, 1, 0, 1, position.xyz + N * 1e-2, tmin, L, tmax, 1);
		}

		// Calculate attenuation factor
		// ----------------------------
		attenuation = light_max_distance - light_distance;
		attenuation /= light_max_distance;
		attenuation = max(attenuation, 0.0);
		attenuation = isDirectional ? 0.3 : (attenuation * attenuation);

		if(isShadowed || light_intensity == 0)
			attenuation = 0.0;
		
		tmax = 10000.0;

		// Calculate illumination
		//-----------------------
		// In case material is diffuse, no need to ray trace at the moment
		vec3 rayColor = vec3(1);
		if( shadingMode == 0)
		{
			vec3 difColor = computeDiffuse(mat, N, L);
			//vec3 specular = isShadowed ? vec3(0) : computeSpecular(mat, N, L, V);
			rayColor *= difColor * light.color.xyz * light_intensity * attenuation;
		}
		else if(shadingMode == 3)
		{
			direction 			= reflect(normalize(-V), N);
			origin 				= position;
			vec3 difColor 		= computeDiffuse(mat, N, L);
			//vec3 specular 		= computeSpecular(mat, N, L, V);
			rayColor *= difColor * light.color.xyz * light_intensity * attenuation;		
			for(;depth < MAX_RECURSION; depth++)
			{
				traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + direction * 1e-2, tmin, direction, tmax, 0);
				rayColor 		*= prd.colorAndDist.xyz;

				if(prd.direction.w == 0 || prd.colorAndDist.w < 0)
				{
					break;
				}
				origin 			= prd.origin;
				direction 		= prd.direction.xyz;
			}
		}
		else if(shadingMode == 4)
		{
			float ior 				= mat.diffuse.w;
			origin 					= position;
			const float cosAlpha 	= dot(N, V);
			const vec3 				I = -V; // incident ray
			float NdotI 			= dot( N, I );
			vec3 refrNormal 		= NdotI > 0.0 ? -N : N;
			float refrEta 			= NdotI > 0.0 ?  1 / ior : ior;

			prd.direction.w 		= 1;
			
			float radicand = 1 + pow(refrEta, 2.0) * (cosAlpha * cosAlpha - 1);
			direction = radicand < 0.0 ? reflect(I, N) : refract(I, refrNormal, refrEta);
			rayColor *= mat.diffuse.xyz * light_intensity * light.color.xyz;
			for(;depth < MAX_RECURSION; depth++)
			{
				traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + direction * 1e-2, tmin, direction, tmax, 0);
				rayColor *= prd.colorAndDist.xyz;

				if(prd.direction.w == 0 || prd.colorAndDist.w < 0)
				{
					break;
				}
				origin 			= prd.origin;
				direction 		= prd.direction.xyz;
			}
		}	
		finalColor += rayColor;
	}
	
	if(!background)
		finalColor *= albedo;
	else
		finalColor = albedo;

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(finalColor, 0.0));
}