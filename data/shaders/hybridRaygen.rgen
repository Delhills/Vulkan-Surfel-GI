#version 460
#extension GL_EXT_ray_tracing : require
#extension GL_EXT_nonuniform_qualifier : enable
#extension GL_EXT_scalar_block_layout : enable
#extension GL_GOOGLE_include_directive : enable

#include "raycommon.glsl"
#include "helpers.glsl"

layout (set = 0, binding = 0) uniform accelerationStructureEXT topLevelAS;
layout (set = 0, binding = 1, rgba8) uniform image2D image;
layout (set = 0, binding = 2) uniform CameraProperties 
{
	mat4 viewInverse;
	mat4 projInverse;
} cam;
layout (set = 0, binding = 3) uniform sampler2D positionTexture;
layout (set = 0, binding = 4) uniform sampler2D normalTexture;
layout (set = 0, binding = 5) uniform sampler2D albedoTexture;
//layout (set = 0, binding = 6) uniform sampler2D materialTexture;
layout (std140, set = 0, binding = 7) uniform Lights { Light lights[1]; } lightsBuffer;
layout (set = 0, binding = 11) uniform MaterialBuffer { Material mat[10]; } materials;

layout(location = 0) rayPayloadEXT hitPayload prd;
layout(location = 1) rayPayloadEXT bool isShadowed;

const int MAX_RECURSION = 10;

void main()
{

	prd.seed = tea(gl_LaunchIDEXT.y * gl_LaunchSizeEXT.x + gl_LaunchIDEXT.x, gl_LaunchIDEXT.x * gl_LaunchSizeEXT.y);

    const vec2 pixelCenter	= vec2(gl_LaunchIDEXT.xy) + vec2(0.5);	// gl_LaunchIDEXT represents the floating-point pixel coordinates normalized between 0 and 1
	const vec2 inUV 		= pixelCenter/vec2(gl_LaunchSizeEXT.xy);	//gl_LaunchSizeExt is the image size provided in the traceRayEXT function
	vec2 d 					= inUV * 2.0 - 1.0;

    vec3 position 			= texture(positionTexture, inUV).xyz;
	float matIdx 			= round(texture(positionTexture, inUV).w * 10);
	vec3 normal 			= texture(normalTexture, inUV).xyz * 2.0 - vec3(1);
	vec3 albedo 			= texture(albedoTexture, inUV).xyz;
	//vec4 material 		= texture(materialTexture, inUV);

	// Using the pixel coordinates we can apply the inverse transformation of the view and procjection matrices of the camera to obtain
	// the origin and target of the ray
	vec4 camPosition 		= cam.viewInverse * vec4(0,0,0,1);
    vec3 V 					= position - camPosition.xyz;
    vec3 N 					= normalize(normal);

	float tmin 				= 0.001;
	float tmax 				= 10000.0;

	//matIdx = 1;
	Material mat = materials.mat[int(matIdx)];

	vec3 color 		= vec3(0);
	vec3 origin 	= vec3(0);
	vec3 direction 	= vec3(0);

	for(int i = 0; i < lightsBuffer.lights.length(); i++)
	{
		Light light 				= lightsBuffer.lights[i];
		vec3 L 						= normalize(light.pos.xyz - position.xyz);
		float NdotL 				= clamp(dot(N, L), 0.0, 1.0);

		float light_max_distance 	= light.pos.w;
		float light_distance 		= length(light.pos.xyz - position);
		float light_intensity 		= light.color.w / (light_distance * light_distance);

		// Calculate attenuation factor
		float attenuation = light_max_distance - light_distance;
		attenuation /= light_max_distance;
		attenuation = max(attenuation, 0.0);
		attenuation = attenuation * attenuation;

		isShadowed = true;

		if(NdotL > 0)
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 1, 0, 1, position.xyz + N * 0.01f, tmin, L, tmax, 1);
		if(isShadowed)
			attenuation = 0;

		// Calculate illumination

		origin 		= position;
		direction 	= reflect(N, -V);
		for(int n = 0; n < MAX_RECURSION; n++)
		{
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + N * 0.1f, tmin, direction, tmax, 0);
			bool isScattered = prd.direction.w > 0;
			if(!isScattered || prd.colorAndDist.w <= 0){
				color += (prd.colorAndDist.xyz * light.color.xyz) * attenuation * light_intensity;;
				break;
			}
			else{
				origin 		= prd.origin.xyz;
				direction 	= prd.direction.xyz;
			}
		}

		// In case material is diffuse, no need to ray trace at the moment
		if(mat.illum == 0)
		{
			//hitPayload pay = Scatter(mat, -normalize(V), N, L, length(V), prd.seed);
			vec3 difColor = computeDiffuse(mat, N, L);
			vec3 specular = isShadowed ? computeSpecular(mat, N, L, V) : vec3(0);
			color += (difColor * mat.diffuse.xyz + specular) * light.color.xyz * attenuation * light_intensity;
		}
		else if(mat.illum == 3)
		{
			origin 		= position;
			direction 	= reflect(V, N);
			traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + N, tmin, direction, tmax, 0);
			vec3 difColor = computeDiffuse(mat, N, L);
			color += prd.colorAndDist.xyz * difColor * light.color.xyz * attenuation * light_intensity;
			/*
			origin 		= position;
			direction 	= reflect(N, -V);
			for(int n = 0; n < MAX_RECURSION; n++)
			{
				traceRayEXT(topLevelAS, gl_RayFlagsOpaqueEXT, 0xff, 0, 0, 0, origin.xyz + N * 0.1f, tmin, direction, tmax, 0);
				bool isScattered = prd.direction.w > 0;
				if(!isScattered || prd.colorAndDist.w <= 0){
					color += (prd.colorAndDist.xyz * light.color.xyz) * attenuation * light_intensity;;
					break;
				}
				else{
					origin 		= prd.origin.xyz;
					direction 	= prd.direction.xyz;
				}
			}
			*/
		}
	}

    imageStore(image, ivec2(gl_LaunchIDEXT.xy), vec4(color, 0.0));
}